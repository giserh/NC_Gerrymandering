<?xml version="1.0" encoding="UTF-8"?>

<solver>
	<!-- <environmentMode>FAST_ASSERT</environmentMode> -->

	<scanAnnotatedClasses />


	<!-- Score configuration -->
	<scoreDirectorFactory>
		<scoreDrl>solver/gerrymanderingRules.drl</scoreDrl>
	</scoreDirectorFactory>

	<!-- Optimization algorithms configuration -->

	<termination>
		<minutesSpentLimit>30</minutesSpentLimit>
	</termination>

	<!-- Optimization algorithms configuration -->
	<constructionHeuristic />
	<localSearch>
		<termination>
			<minutesSpentLimit>20</minutesSpentLimit>
		</termination>
		<!-- <acceptor> <entityTabuSize>7</entityTabuSize> </acceptor> <forager> <acceptedCountLimit>1000</acceptedCountLimit> 
			</forager> -->
		<!-- <unionMoveSelector> <changeMoveSelector /> <swapMoveSelector /> -->
		<!-- To escape the local optimum in this knapsack variant, add pillar swap moves to swap 2 sets of states. -->
		<!-- <pillarSwapMoveSelector /> </unionMoveSelector> <forager> <acceptedCountLimit>1000</acceptedCountLimit> </forager> -->

	</localSearch>

	<localSearch>
		<pillarSwapMoveSelector>
			<pillarSelector>
				<subPillarEnabled>true</subPillarEnabled>
				<minimumSubPillarSize>1</minimumSubPillarSize>
				<maximumSubPillarSize>4</maximumSubPillarSize>
			</pillarSelector>
		</pillarSwapMoveSelector>

	</localSearch>


</solver>